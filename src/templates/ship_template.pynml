<tal:call_global_template define="global_template load: global_template.pt" metal:use-macro="global_template" />

// -- begin ${ship.title} -- <!--! this adds a comment to aid reading the final nml -->

<tal:include condition="ship.graphics_template=='default'" define="graphics_default load: graphics_default.pynml" metal:use-macro="graphics_default" />
<tal:include condition="ship.graphics_template=='hydrofoil'" define="graphics_hydrofoil load: graphics_hydrofoil.pynml" metal:use-macro="graphics_hydrofoil" />
<tal:include condition="ship.graphics_template=='2_visible_cargo_states'" define="graphics_2_visible_cargo_states load: graphics_2_visible_cargo_states.pynml" metal:use-macro="graphics_2_visible_cargo_states" />
<tal:include condition="ship.graphics_template=='standard_gcv'" define="graphics_standard_gcv load: graphics_standard_gcv.pynml" metal:use-macro="graphics_standard_gcv" />
<tal:include condition="ship.graphics_template=='tanker'" define="graphics_tanker load: graphics_tanker.pynml" metal:use-macro="graphics_tanker" />

<tal:capacity_no_subtype_refits condition="python:ship.capacity_is_refittable_by_cargo_subtype == False">
    // -- capacity determined according to specific labels that might need to be handled, and otherwise cargo class -- //
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_cargo_capacity_classes, cargo_classes) {
        bitmask(CC_PASSENGERS): return ${ship.capacity_pax};
        bitmask(CC_MAIL): return ${ship.capacity_mail};
        return ${ship.capacity_freight};
    }
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_cargo_capacity, cargo_type_in_veh) {
        <tal:trawlers condition="ship.str_type_info.lower()=='trawler'">FISH: return ${ship.capacity_special[0]};</tal:trawlers>
        ${ship.id}_switch_cargo_capacity_classes;
    }

    // -- handle subtype strings, used to aid players understand auto-refitting -- //
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_cargo_subtype_text, cargo_subtype) {
        return CB_RESULT_NO_TEXT;
    }
</tal:capacity_no_subtype_refits>

<tal:capacity_subtype_refits condition="python:ship.capacity_is_refittable_by_cargo_subtype == True">
    // -- ships that have subtype refits for capacity rely on the capacity_special prop, do not use capcity from mail / pax / cargo holds / tanks -- //
    <!--! assumes exactly 3 subtype refits, which is a sane amount; convert to repeat if more are ever needed -->
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_cargo_capacity, cargo_subtype) {
        0: return ${ship.capacity_special[0]};
        1: return ${ship.capacity_special[1]};
        2: return ${ship.capacity_special[2]};
        return ${ship.capacity_special[0]};
    }

    // -- handle subtype strings, used to aid players understand auto-refitting -- //
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_cargo_subtype_text, cargo_subtype) {
        0: return string(STR_GENERIC_REFIT_SUBTYPE, ${ship.capacity_special[0]}, ${ship.get_cargo_suffix()});
        1: return string(STR_GENERIC_REFIT_SUBTYPE, ${ship.capacity_special[1]}, ${ship.get_cargo_suffix()});
        2: return string(STR_GENERIC_REFIT_SUBTYPE, ${ship.capacity_special[2]}, ${ship.get_cargo_suffix()});
        return CB_RESULT_NO_TEXT;
    }
</tal:capacity_subtype_refits>


// -- dibble about with purchase menu capacity to handle various cargo-specific capacity issues (cargo might be missing etc) -- //
switch (FEAT_SHIPS, SELF, ${ship.id}_switch_purchase_cargo_capacity, cargo_type_in_veh) {
    <tal:trawlers condition="ship.str_type_info.lower()=='trawler'">
        FISH: return ${ship.capacity_special[0]};
        PASS: return ${ship.capacity_pax};
    </tal:trawlers>
    return ${ship.default_cargo_capacity};
}



// -- set speed a little higher than rated speed when unladen -- //
// -- also apply the param_adjust_ship_speed parameter -- //
<tal:speed repeat="speed_factor python:range(3)">
    switch (FEAT_SHIPS, SELF, ${ship.id}_switch_speed_varies_with_load_amount_${speed_factor}, cargo_count*100/cargo_capacity) {
        0 : ${ship.get_speeds_adjusted_for_load_amount(speed_factor)[0]};
        1..25 : ${ship.get_speeds_adjusted_for_load_amount(speed_factor)[1]};
        26..50 : ${ship.get_speeds_adjusted_for_load_amount(speed_factor)[2]};
        51..75 : ${ship.get_speeds_adjusted_for_load_amount(speed_factor)[3]};
        76..100 : ${ship.get_speeds_adjusted_for_load_amount(speed_factor)[4]};
        return 0; // should never reach this result, make it show up as a problem
    }
</tal:speed>
switch (FEAT_SHIPS, SELF, ${ship.id}_switch_speed_varies_with_load_amount, param_adjust_ship_speed) {
    0: ${ship.id}_switch_speed_varies_with_load_amount_0;
    1: ${ship.id}_switch_speed_varies_with_load_amount_1;
    2: ${ship.id}_switch_speed_varies_with_load_amount_2;
}
switch (FEAT_SHIPS, SELF, ${ship.id}_switch_purchase_speed, param_adjust_ship_speed) {
    0: ${ship.get_speeds_adjusted_for_load_amount(0)[4]};
    1: ${ship.get_speeds_adjusted_for_load_amount(1)[4]};
    2: ${ship.get_speeds_adjusted_for_load_amount(2)[4]};
}


// -- print some of the ship non-nml properties to aid debugging -- //
// [no properties printed]

item(FEAT_SHIPS, ${ship.id}, ${ship.numeric_id}) {
    property {
        name:                           ${ship.get_name()};
        climates_available:             ALL_CLIMATES; // nml constant
        sound_effect:                   ${('SOUND_SHIP_HORN','SOUND_FERRY_HORN')[ship.default_cargo=='PASS']};
        <!--! visual_effect:                  visual_effect(VISUAL_EFFECT_DIESEL, ${ship.smoke_offset}); // nml constant for DIESEL-->
        introduction_date:              date(${ship.intro_date},01,01); // ship just supplies intro year - openttd randomises intro dates a bit anyway
        cargo_capacity:                 ${ship.default_cargo_capacity};
        sprite_id:                      SPRITE_ID_NEW_SHIP; //enable new graphics - nml constant
        speed:                          ${ship.speed}mph;
        ocean_speed_fraction:           ${ship.ocean_speed};
        canal_speed_fraction:           ${ship.canal_speed};
        cost_factor:                    ${ship.buy_cost};
        running_cost_factor:            ${ship.running_cost};
        refit_cost:                     0;
        is_refittable:                  1;
        refittable_cargo_classes:       bitmask(${ship.refittable_classes});
        non_refittable_cargo_classes:   bitmask();
        cargo_allow_refit:              [${ship.get_label_refits_allowed()}];
        cargo_disallow_refit:           [${ship.get_label_refits_disallowed()}];
        default_cargo_type:             ${ship.default_cargo};
        loading_speed:                  ${ship.loading_speed};
        misc_flags:                     bitmask(SHIP_FLAG_2CC, SHIP_FLAG_AUTOREFIT); // nml constants
        model_life:                     ${ship.adjusted_model_life};
        retire_early:                   ${ship.vehicle_life - 4}; // magic from Eddi
        reliability_decay:              20; // default value
        vehicle_life:                   ${ship.vehicle_life};
    }
    graphics {
        speed:                          ${ship.id}_switch_speed_varies_with_load_amount;
        purchase_speed:                 ${ship.id}_switch_purchase_speed;
        cargo_capacity:                 ${ship.id}_switch_cargo_capacity;
        purchase_cargo_capacity:        ${ship.id}_switch_purchase_cargo_capacity;
        additional_text:                ${ship.get_buy_menu_string()};
        cargo_subtype_text:             ${ship.id}_switch_cargo_subtype_text;
        refit_cost:                     ${ship.id}_switch_refit_cost;
        default:                        ${ship.id}_switch_graphics;
        purchase:                       ${ship.id}_sg_purchase;
    }
}


// -- end ${ship.title} -- <!--! another comment to aid reading the final nml  -->
